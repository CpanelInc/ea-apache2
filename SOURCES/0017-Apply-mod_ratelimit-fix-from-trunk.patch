From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Rishwanth Yeddula <rish@cpanel.net>
Date: Fri, 24 Aug 2018 15:28:35 -0500
Subject: [PATCH 17/17] Apply mod_ratelimit fix from trunk

Original commit message:
mod_ratelimit: Don't interfere with "chunked" encoding.

By the time ap_http_header_filter() sends the header brigade and adds the
"CHUNK" filter, we need to garantee that the header went through all the
filters' stack, and more specifically above ap_http_chunk_filter() which
assumes that all it receives is content data.

Since rate_limit_filter() may retain the header brigade, make it run after
ap_http_chunk_filter(), just before AP_FTYPE_CONNECTION filters.

This fixes the regression introduced in 2.4.34 (r1835168).
PR 62568.

git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1837130 13f79535-47bb-0310-9956-ffa450edef68
---
 modules/filters/mod_ratelimit.c |  2 +-
 modules/http/chunk_filter.c     |  3 ++-
 modules/http/http_filters.c     | 13 ++++++++++++-
 3 files changed, 15 insertions(+), 3 deletions(-)

diff --git a/modules/filters/mod_ratelimit.c b/modules/filters/mod_ratelimit.c
index cf79973..49180c4 100644
--- a/modules/filters/mod_ratelimit.c
+++ b/modules/filters/mod_ratelimit.c
@@ -327,7 +327,7 @@ static void register_hooks(apr_pool_t *p)
 {
     /* run after mod_deflate etc etc, but not at connection level, ie, mod_ssl. */
     ap_register_output_filter(RATE_LIMIT_FILTER_NAME, rate_limit_filter,
-                              NULL, AP_FTYPE_PROTOCOL + 3);
+                              NULL, AP_FTYPE_CONNECTION - 1);
 }
 
 AP_DECLARE_MODULE(ratelimit) = {
diff --git a/modules/http/chunk_filter.c b/modules/http/chunk_filter.c
index 17fbabd..cb1501a 100644
--- a/modules/http/chunk_filter.c
+++ b/modules/http/chunk_filter.c
@@ -69,6 +69,7 @@ apr_status_t ap_http_chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
         {
             if (APR_BUCKET_IS_EOS(e)) {
                 /* there shouldn't be anything after the eos */
+                ap_remove_output_filter(f);
                 eos = e;
                 break;
             }
@@ -186,11 +187,11 @@ apr_status_t ap_http_chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
 
         /* pass the brigade to the next filter. */
         rv = ap_pass_brigade(f->next, b);
+        apr_brigade_cleanup(b);
         if (rv != APR_SUCCESS || eos != NULL) {
             return rv;
         }
         tmp = b;
-        apr_brigade_cleanup(tmp);
     }
     return APR_SUCCESS;
 }
diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index 5fa4063..37c0113 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -1308,8 +1308,19 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
     else if (ctx->headers_sent) {
         /* Eat body if response must not have one. */
         if (r->header_only || r->status == HTTP_NO_CONTENT) {
+            /* Still next filters may be waiting for EOS, so pass it (alone)
+             * when encountered and be done with this filter.
+             */
+            e = APR_BRIGADE_LAST(b);
+            if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                apr_brigade_cleanup(b);
+                APR_BRIGADE_INSERT_HEAD(b, e);
+                ap_remove_output_filter(f);
+                rv = ap_pass_brigade(f->next, b);
+            }
             apr_brigade_cleanup(b);
-            return APR_SUCCESS;
+            return rv;
         }
     }
 
