From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tim Mullin <tim@cpanel.net>
Date: Tue, 28 Dec 2021 20:52:22 +0000
Subject: [PATCH 21/21] Active daemons accounting fix plus idle worker waking
 up the listener when listeners disabled for bug #65769

---
 server/mpm/event/event.c | 36 +++++++++++++++++++++++++++++++-----
 1 file changed, 31 insertions(+), 5 deletions(-)

diff --git a/server/mpm/event/event.c b/server/mpm/event/event.c
index a54f76a..5a7a407 100644
--- a/server/mpm/event/event.c
+++ b/server/mpm/event/event.c
@@ -1859,11 +1859,9 @@ static void * APR_THREAD_FUNC listener_thread(apr_thread_t * thd, void *dummy)
                 else if (connections_above_limit(&workers_were_busy)) {
                     disable_listensocks();
                     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-                                 "Too many open connections (%u), "
+                                 "Too many open connections (%u, %u idlers), "
                                  "not accepting new conns in this process",
-                                 apr_atomic_read32(&connection_count));
-                    ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, ap_server_conf,
-                                 "Idle workers: %u",
+                                 apr_atomic_read32(&connection_count),
                                  ap_queue_info_num_idlers(worker_queue_info));
                 }
                 else if (!listener_may_exit) {
@@ -2081,6 +2079,9 @@ static void *APR_THREAD_FUNC worker_thread(apr_thread_t * thd, void *dummy)
                 signal_threads(ST_GRACEFUL);
                 break;
             }
+            if (listener_is_wakeable && !dying && listeners_disabled()) {
+                apr_pollset_wakeup(event_pollset);
+            }
             is_idle = 1;
         }
 
@@ -2164,6 +2165,12 @@ static void *APR_THREAD_FUNC worker_thread(apr_thread_t * thd, void *dummy)
         }
     }
 
+#if 0
+    if (is_idle) {
+        ap_queue_info_unset_idle(worker_queue_info);
+    }
+#endif
+
     ap_update_child_status_from_indexes(process_slot, thread_slot,
                                         dying ? SERVER_DEAD
                                               : SERVER_GRACEFUL, NULL);
@@ -2793,6 +2800,12 @@ static void perform_idle_server_maintenance(int child_bucket)
     int i, j;
 
     for (i = 0; i < server_limit; ++i) {
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                     "perform_idle_server_maintenance(%i/%i): "
+                     "slot %i/%i, free %i/%i",
+                     child_bucket, num_buckets,
+                     i, retained->max_daemons_limit,
+                     free_length, retained->idle_spawn_rate[child_bucket]);
         if (num_buckets > 1 && (i % num_buckets) != child_bucket) {
             /* We only care about child_bucket in this call */
             continue;
@@ -2808,6 +2821,13 @@ static void perform_idle_server_maintenance(int child_bucket)
         ps = &ap_scoreboard_image->parent[i];
         if (ps->pid != 0) {
             int child_threads_active = 0;
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                         "perform_idle_server_maintenance(%i/%i): "
+                         "slot %i/%i, pid %i, quiescing %i, daemons %i/%i",
+                         child_bucket, num_buckets,
+                         i, retained->max_daemons_limit,
+                         (int)ps->pid, ps->quiescing,
+                         retained->active_daemons, retained->total_daemons);
             if (ps->quiescing == 1) {
                 ps->quiescing = 2;
                 retained->active_daemons--;
@@ -3045,7 +3065,13 @@ static void server_main_loop(int remaining_children_to_start)
 
                 event_note_child_killed(child_slot, 0, 0);
                 ps = &ap_scoreboard_image->parent[child_slot];
-                if (!ps->quiescing)
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                             "server_main_loop(): "
+                             "slot %i/%i, pid %i, quiescing %i, daemons %i/%i",
+                             child_slot, retained->max_daemons_limit,
+                             (int)ps->pid, ps->quiescing,
+                             retained->active_daemons, retained->total_daemons);
+                if (ps->quiescing != 2)
                     retained->active_daemons--;
                 ps->quiescing = 0;
                 /* NOTE: We don't dec in the (child_slot < 0) case! */
