diff -u -r httpd-2.4.29.old/server/log.c httpd-2.4.29/server/log.c
--- a/server/log.c       2017-09-08 10:17:21.000000000 +0000
+++ b/server/log.c   2017-12-24 11:21:58.485818120 +0000
@@ -1805,19 +1805,19 @@
     break;

     case APR_OC_REASON_RESTART:
-        if (pl->pid != NULL) {
-            apr_proc_kill(pl->pid, SIGTERM);
-            pl->pid = NULL;
-        }
+       /* Apache wants to SIGTERM piped loggers during SIGUSR1 (graceful),
+        * but this introduces a race condition since the MPM's don't prevent multiple gracefuls from happening
+        * around the same time which, can cause EPIPE to the piped logger when it's respawning. We should just avoid killing it
+        * because when the piped logger sees EOF, it will die anyways. See EA-6020
+       */
         break;
-
     case APR_OC_REASON_UNREGISTER:
         break;
     }
 }


-static apr_status_t piped_log_cleanup_for_exec(void *data)
+static apr_status_t piped_log_cleanup(void *data)
 {
     piped_log *pl = data;

@@ -1826,18 +1826,6 @@
     return APR_SUCCESS;
 }

-
-static apr_status_t piped_log_cleanup(void *data)
-{
-    piped_log *pl = data;
-
-    if (pl->pid != NULL) {
-        apr_proc_kill(pl->pid, SIGTERM);
-    }
-    return piped_log_cleanup_for_exec(data);
-}
-
-
 AP_DECLARE(piped_log *) ap_open_piped_log_ex(apr_pool_t *p,
                                              const char *program,
                                              apr_cmdtype_e cmdtype)
@@ -1854,8 +1842,7 @@
                                 APR_FULL_BLOCK, p) != APR_SUCCESS) {
         return NULL;
     }
-    apr_pool_cleanup_register(p, pl, piped_log_cleanup,
-                              piped_log_cleanup_for_exec);
+    apr_pool_cleanup_register(p, pl, piped_log_cleanup, piped_log_cleanup);
     if (piped_log_spawn(pl) != APR_SUCCESS) {
         apr_pool_cleanup_kill(p, pl, piped_log_cleanup);
         apr_file_close(pl->read_fd);
